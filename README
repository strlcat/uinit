uinit - well, almost smallest SysV compatible init possible.

HOW IT WORKS

uinit is a simple init skeleton which is called by kernel directly
(executing /sbin/init as first process). It then disables
Ctrl-Alt-Delete sequence and executes /etc/init/boot script as it's child which is
responsible for further system rollup. Beyond that, init only waits for
ended orphaned processes.

Writing /etc/init/boot is a duty of a system designer. It's not
included (nor any of additional scripts), because I think everyone can
adapt their own or write from scratch. Additionally, the following
scripts are needed (but they can be a hard/symlink to a more general script):

/etc/init/reboot - gets executed when system is going to be rebooted
/etc/init/poweroff - gets executed when system is shutting down
/etc/init/shutdown - gets executed when system will be halted
/etc/init/cad - gets executed when user typed Ctrl-Alt-Delete on system
console
/etc/init/single - gets executed when init goes into singleuser mode
/etc/init/powerfail - gets executed when init receives SIGPWR. System
administrator can install a UPS monitoring service which then, on power
failure, will send SIGPWR to any process in system. Someone have to catch
this on, and call /sbin/powerfail properly to tell init it've got power problem.

/etc/init/altinit - this is preinit script. It is usually not needed (and can be safely omitted),
but can be used as a fallback when you have no chance to specify init=
kernel parameter. init process replaces itself with this script if it
exists, and script gets pid 1. It can continue execution out by
executing /sbin/init again with _INIT environment variable set to any
value:

	#!/bin/sh
	# ... Do your preinit stuff there ...
	_INIT=1 exec /sbin/init

Internally uinit is controlled by sending commands to it's control socket, default is /dev/initctl.
This socket must be created manually in your /etc/init/boot somewhere between initializing /dev
devtmpfs filesystem (for example, after udev startup) but before going multiuser, by calling /sbin/mkinitctl.
See source for details. init sets socket mode so nobody other than superuser can send commands to it.
It also checks permissions at runtime even if someone successfully connects to it.

WHY

Because I wanted to learn how Linux system boots. And following recent saga about init madness, I wanted something
very simple and controllable. It's mostly an init system for embedded devices, but can serve well even on desktops.

HOW TO USE IT

Installing the programs is recommended when you're building your own system. Replacing existing init with uinit can be
risky. You should have prepared your own boot scripts already and have them in place.

/sbin/init is called by kernel at system startup. Normally you should never call it when system is running.
But if you do, it will just exit if it's not a pid 1, it's safe to do so. It does not accept any command line arguments.

/sbin/shutdown is called when system needs to be turned off. When called as 'shutdown', the program will, according
to command line, bring the system down IMMEDIATELY. Without arguments it will just show a help.

Calling `/sbin/shutdown -H` will halt your system. It will not show the help screen :-)

'-H' will halt, '-P' will power down if possible, '-R' will reboot the system.

When called as 'reboot', 'poweroff', 'powerfail', 'halt' or 'singleuser' (process name),
the program will instead send commands to running init.
If connecting to control socket fails, some of these commands will initiate immediate system shutdown.
But if connection is successful and command is understood, then system will not be halted immediately,
but init will run the scripts to do so. init assumes that all shutdown-like sequences are final, and so,
there is no currently way to cancel an initiated shutdown. init will simply disable control socket, and proceed like
shutdown is inevitable. The only exception is powerfail condition: init just will run a powerfail script, while
continuing to run as usual. powerfail script can then initiate full system shutdown afterwards.

Unprivileged user usually can't send control socket commands, or directly control system shutdown.
The errors are ignored then, /sbin/shutdown does not report them. This is normal.

/sbin/mkinitctl tells init to create it's control socket, /dev/initctl. You shall call it after /dev
is properly initialized. init also will try to create this socket after 10 seconds since it was run,
and if it will fail, nothing bad will happen. You always can manually call /sbin/mkinitctl later.
Beware that system running without init control socket can be very easily halted without a notice!

/sbin/telinit does nothing. This is provided for minimal SysV compatibility for Slackware.

Calling /sbin/shutdown with '-w', as well as it's aliases is also noop, for same reason.

/sbin/respawn is a little supervising program. The program to be spawned is given in it's command line (including arguments).
Then respawn runs it as it's child, watches it's state and respawns it if it exited. Respawn must be killed to stop respawning
the program, or countdown must be specified. It supports specifying respawn counts, delay between respawns and controlling
tty the child will have, which must already exist. This tty is opened then, asigned as standard three Unix IO streams.

'-T' specifies path to tty, '-t' specifies time between respawns, '-n' specifies maximum count of respawns.

Singleuser mode is recommended to be implemented as a normal shutdown sequence, but instead of calling
an appropriate shutdown command, spawn a /bin/sh instead at the very system console. This is how I understand
a true singleuser mode: a complete system cleanup followed by spawning a shell at the system console.

A sample set of bootstrap scripts is provided for your own amusement in `initrc.tar.gz` file there.
They shall give you idea about what's going on. These scripts are designed to boot stock SysV-scripts
that are shipped with Slackware 15.x distro. These bootstrap scripts ARE NOT REPLACEMENT for your existing ones!

LIMITATIONS

Of course if you want full-blown runtime features other than fundamental system control, then this is not your init.

Things that are not going to be supported:
- Runlevels
- Suck in any parts from userspace
- Sending signals, watching processes other than reaping orphans
- Configuration file(s)
- Exporting it's own control api via any mechanism (other than opaque one via control socket which might change in future)
- Other features which you can see in various init systems I'm unaware of.

In fact, this is already finished init program which can be used everywhere. I don't plan any further changes.

Rys, Aug2023.
